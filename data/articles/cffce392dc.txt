How GitHub Copilot and AI agents are saving legacy systems - The GitHub Blog
Learn about artificial intelligence and machine learning across the GitHub ecosystem and the wider industry.
Explore the capabilities and benefits of AI code generation and how it can improve your developer experience.
Resources for developers to grow in their skills and careers.
Learn how to move into your first professional role.
Learn how to start building, shipping, and maintaining software with GitHub.
Get an inside look at how we’re building the home for all developers.
Discover how we deliver a performant and highly available experience across the GitHub platform.
Explore best practices for building software at scale with a majority remote team.
Get a glimpse at the technology underlying the world’s leading AI-powered developer platform.
Learn how we build security into everything we do across the developer lifecycle.
Find out what goes into making GitHub the home for all developers.
How we use GitHub to be more productive, collaborative, and secure
Our engineering and security teams do some incredible work. Let’s take a look at how we use GitHub to be more productive, build collaboratively, and shift security left.
Explore how to write, build, and deploy enterprise software at scale.
Automating your way to faster and more secure ships.
Tips, tools, and tricks to improve developer collaboration.
GitHub recognized as a Leader in the Gartner® Magic Quadrant™ for AI Code Assistants
Learn why Gartner positioned GitHub as a Leader for the second year in a row.
Keep up with what’s new and notable from inside GitHub.
An inside look at news and product updates from GitHub.
The latest on GitHub’s platform, products, and tools.
The latest policy and regulatory changes in software.
Data-driven insights around the developer ecosystem.
Learn how to use retrieval-augmented generation (RAG) to capture more insights.
Organizations worldwide are incorporating open source methodologies into the way they build and ship their own software.
Learn about core challenges in DevSecOps, and how you can start addressing them with AI and automation.
Learn about artificial intelligence and machine learning across the GitHub ecosystem and the wider industry.
Explore the capabilities and benefits of AI code generation and how it can improve your developer experience.
Resources for developers to grow in their skills and careers.
Learn how to move into your first professional role.
Learn how to start building, shipping, and maintaining software with GitHub.
Get an inside look at how we’re building the home for all developers.
Discover how we deliver a performant and highly available experience across the GitHub platform.
Explore best practices for building software at scale with a majority remote team.
Get a glimpse at the technology underlying the world’s leading AI-powered developer platform.
Learn how we build security into everything we do across the developer lifecycle.
Find out what goes into making GitHub the home for all developers.
How we use GitHub to be more productive, collaborative, and secure
Our engineering and security teams do some incredible work. Let’s take a look at how we use GitHub to be more productive, build collaboratively, and shift security left.
Explore how to write, build, and deploy enterprise software at scale.
Automating your way to faster and more secure ships.
Tips, tools, and tricks to improve developer collaboration.
GitHub recognized as a Leader in the Gartner® Magic Quadrant™ for AI Code Assistants
Learn why Gartner positioned GitHub as a Leader for the second year in a row.
Keep up with what’s new and notable from inside GitHub.
An inside look at news and product updates from GitHub.
The latest on GitHub’s platform, products, and tools.
The latest policy and regulatory changes in software.
Data-driven insights around the developer ecosystem.
Learn how to use retrieval-augmented generation (RAG) to capture more insights.
Organizations worldwide are incorporating open source methodologies into the way they build and ship their own software.
Learn about core challenges in DevSecOps, and how you can start addressing them with AI and automation.
How GitHub Copilot and AI agents are saving legacy systems
GitHub Copilot and AI agents are making legacy COBOL systems accessible to modern developers.
Picture this: you’re a developer in 2025, and your company just told you they need to modernize a mainframe system that processes millions of ATM transactions daily. We’re talking about
, a programming language that’s been around for 65 years. That’s older than the internet.
Now, your first instinct might be to laugh or maybe cry a little. But here’s the thing—COBOL isn’t going anywhere. In fact, it’s powering some of the largest and most critical systems on the planet right now.
Finding developers who understand COBOL is like finding unicorns.
The original developers are retiring, and yet 200 billion lines of COBOL code are still running our banks, insurance companies, and government systems.
But here’s the plot twist: we now have the opportunity to support the unicorns. We have GitHub Copilot and autonomous AI agents.
Meet the developer who’s modernizing COBOL (without learning COBOL)
, Microsoft Global Black Belt, who’s modernizing COBOL systems using AI. What’s remarkable? She never learned COBOL.
Julia brought her AI expertise and worked directly with the people who had decades of domain knowledge. That partnership is the key insight here. She didn’t need to become a COBOL expert. Instead, she focused on what she does best: designing intelligent solutions. The COBOL experts provided the legacy system knowledge.
When this whole idea of Gen AI appeared, we were thinking about how we can actually use AI to solve this problem that has not been really solved yet.
The three-step framework for AI-powered legacy modernization
Julia and her team at Microsoft have cracked the code (pun intended) with a systematic approach that works for any legacy modernization project, not just COBOL. Here’s their GitHub Copilot powered, battle-tested framework.
Organizations have no idea what their code actually does anymore.
They use it, they depend on it, but understanding it? That’s another story.
This is where GitHub Copilot becomes your archaeological tool. Instead of hiring consultants to spend months analyzing code, you can use AI to:
Automatically identify call chains and dependencies.
Add additional information as comments where needed.
Always have human experts review AI-generated analysis. AI is incredible at pattern recognition, but domain knowledge still matters for business context.
# Business Logic Analysis Generated by GitHub Copilot
- listings.cobol: List management functionality (~100 lines)
- mainframe-example.cobol: Full mainframe program (~10K lines, high complexity)
- Performs balance calculations with overdraft protection
You usually need to add context to help AI understand your code better. Here’s what that looks like:
If your code has Danish, German, or other non-English comments, translate them. Models work better with English context.
COBOL has deterministic patterns. Even if you’ve never written COBOL, you can leverage these patterns because they’re predictable. Here’s how:
COBOL programs always follow the same four-division structure:
IDENTIFICATION DIVISION (metadata about the program)
ENVIRONMENT DIVISION (file and system configurations)
DATA DIVISION (variable declarations and data structures)
Ask GitHub Copilot to map these divisions for you. Use prompts like:
"Identify all the divisions in this COBOL file and summarize what each one does"
"List all data structures defined in the DATA DIVISION and their purpose"
"Extract the main business logic flow from the PROCEDURE DIVISION"
The AI can parse these structured sections and explain them in plain English. You don’t need to understand COBOL syntax. You just need to know that COBOL’s rigid structure makes it easier for AI to analyze than more flexible languages.
Save everything AI generates as markdown files that become the primary reference. Julia explained it this way: “Everything that you let Copilot generate as a preparation, write it down as a markdown file so that it can actually reference these markdown files as source of truth.”
COBOL’s verbosity is actually an advantage here. Statements like
are almost self-documenting. Ask Copilot to extract these business rules into natural language descriptions.
Once you’ve analyzed and enriched individual files, you need to understand how they all fit together. This is where you move from using Copilot interactively to building automated workflows with AI agents.
Julia’s team built a framework using Microsoft Semantic Kernel, which orchestrates multiple specialized agents. Each agent has a specific job, and they work together to handle the complexity that would overwhelm a single AI call.
Here’s what this orchestration looks like in practice:
Generate Mermaid diagrams showing how files interact. One agent reads your COBOL files, another traces the CALL statements between programs, and a third generates a visual diagram. You end up with a map of your entire system without manually tracing dependencies.
Extract business logic (agent 1), generate test cases that validate that logic (agent 2), then generate modern code that passes those tests (agent 3). The tests become your safety net during migration.
Identify utility classes and libraries that you can replace with modern equivalents. An agent analyzes what third-party COBOL libraries you’re using, checks if modern alternatives exist, and flags opportunities to simplify your migration.
Think of it like this: Copilot in your IDE is a conversation. This framework is a production line. Each agent does one thing well, and the orchestration layer manages the workflow between them.
Use Mermaid diagrams to visualize complex dependencies before making any changes. It helps you catch edge cases early. You can generate these diagrams by asking Copilot to trace all CALL statements in your codebase and output them in Mermaid syntax. Mermaid chart example:
Everyone who’s currently promising you, ‘hey, I can solve all your mainframe problems with just one click’ is lying to you.
Full automation is probably at least five years away.
But that doesn’t mean we can’t make massive progress today.
Julia and her team have open-sourced their entire framework. It’s built with Microsoft Semantic Kernel for agentic orchestration and includes:
DependencyMapperAgent, COBOLAnalyzerAgent, JavaConverterAgent
See exactly how much each AI operation costs (usually $2-5 per 1000 lines analyzed)
A configuration and testing script that gets you started quickly
Configure Azure OpenAI endpoint (or use local models for sensitive data)
git clone https://github.com/Azure-Samples/Legacy-Modernization-Agents
This isn’t just about technical debt. It’s about business survival. Organizations are facing a critical shortage of COBOL expertise right when they need it most.
The traditional approach has been to hire expensive consultants, spend 5+ years on manual conversion, and end up with auto-generated code that’s unmaintainable. I’ve seen this play out at multiple organizations. The consultants come in, run automated conversion tools, hand over thousands of lines of generated code, and leave. Then the internal team is stuck maintaining code they don’t understand in a language they’re still learning.
The AI-powered approach changes this. You use AI to understand business logic, generate human-readable modern code, and maintain control of your intellectual property. Your team stays involved throughout the process. They learn the business logic as they go. The code that comes out the other end is something your developers can actually work with.
What a lot of customers do not want to actually give all their intellectual property like a hundred percent to a partner anymore, right? They want to keep it in check.
Start here: your path to becoming the modernization hero
Whether you’re dealing with COBOL, ancient Java, or any legacy system, here’s how you can start today:
Identify one problematic legacy system (start with fewer than 5,000 lines)
Learn prompt engineering for code analysis (try: “Analyze this COBOL program and explain its business purpose in simple terms”)
Consider nonfunctional requirements for cloud-native design
Remember: most COBOL programs are doing simple CRUD operations. They don’t need the complexity of a mainframe. They need the simplicity of modern architecture.
Find a legacy system in your organization. Six-month-old code counts as legacy in our industry. Try using GitHub Copilot to:
Create a migration plan with human validation checkpoints
Share your results on LinkedIn and tag me. I’d love to see what you discover.
The most powerful insight from my conversation with Julia is this:
AI doesn’t replace developer expertise. It amplifies it.
COBOL experts bring irreplaceable domain knowledge. Modern developers bring fresh perspectives on architecture and best practices. AI brings pattern recognition and translation capabilities at scale.
When these three forces work together, legacy modernization transforms from an impossible challenge into an achievable project.
The best time to modernize legacy code was 10 years ago. The second-best time is now.
Special thanks to Julia Kordick, Microsoft Global Black Belt, who shared her insights and experiences that made this blog post possible.
The age of legacy code doesn’t have to be a barrier anymore. With the right AI tools and framework, even 65-year-old COBOL can become approachable, maintainable, and modern.
Andrea is a Senior Developer Advocate at GitHub with over a decade of experience in developer tools. She combines technical depth with a mission to make advanced technologies more accessible. After transitioning from Army service and construction management to software development, she brings a unique perspective to bridging complex engineering concepts with practical implementation. She lives in Florida with her Welsh partner, two sons, and two dogs, where she continues to drive innovation and support open source through GitHub's global initiatives. Find her online @alacolombiadev.
Meet the developer who's modernizing COBOL (without learning COBOL)
The three-step framework for AI-powered legacy modernization
Start here: your path to becoming the modernization hero
The road to better completions: Building a faster, smarter GitHub Copilot with a new custom model
Find out about the latest custom models powering the completions experience in GitHub Copilot.
A practical guide on how to use the GitHub MCP server
Upgrade from a local MCP Docker image to GitHub’s hosted server and automate pull requests, continuous integration, and security triage in minutes — no tokens required.
How to find, install, and manage MCP servers with the GitHub MCP Registry
Learn how to bring structure and security to your AI ecosystem with the GitHub MCP Registry, the single source of truth for managing and governing MCP servers.
The road to better completions: Building a faster, smarter GitHub Copilot with a new custom model
Find out about the latest custom models powering the completions experience in GitHub Copilot.
Have you ever thought about using AI to update community health files for your repositories? This blog shares actionable next steps for doing just that, including a starter kit with a checklist and tutorials on how to create three useful files.
Everything you need to master GitHub, all in one place.
Build what’s next on GitHub, the place for anyone from anywhere to build anything.
Meet the companies and engineering teams that build with GitHub.
Last chance: Save $700 on your IRL pass to Universe and join us on Oct. 28-29 in San Francisco.
Discover tips, technical guides, and best practices in our biweekly newsletter just for devs.
Yes please, I’d like GitHub and affiliates to use my information for personalized communications, targeted advertising and campaign effectiveness. See the